// Copyright (c) 2024 ROS2 KaihongOS Port Project
// Licensed under the Apache License, Version 2.0

#include "rmw_dsoftbus/rmw_dsoftbus.h"
#include "rmw_dsoftbus/types.h"
\n#include <rcutils/allocator.h>  // Foundation layer memory management

#include <cstring>
#include <ctime>
#include <memory>
#include <fcntl.h>
#include <unistd.h>

// Forward declarations for dsoftbus adapter
namespace rmw_dsoftbus {
    extern std::string encode_service_for_session(const char* service_name);
    extern int create_service_server(const char* service_name, const char* type_name, void* service_impl);
    extern void destroy_service_server(const char* service_name);
    extern int send_service_response(const char* service_name, int client_session_id,
                                     int64_t request_id, const void* response_data, unsigned int len,
                                     const uint8_t* service_gid);
    extern bool is_service_available(const char* service_name);
}

extern "C"
{

rmw_service_t * rmw_create_service(
    const rmw_node_t * node,
    const rosidl_service_type_support_t * type_support,
    const char * service_name,
    const rmw_qos_profile_t * qos_policies)
{
    if (!node) {
        RMW_SET_ERROR_MSG("node is null");
        return nullptr;
    }
    if (!type_support) {
        RMW_SET_ERROR_MSG("type_support is null");
        return nullptr;
    }
    if (!service_name || strlen(service_name) == 0) {
        RMW_SET_ERROR_MSG("service_name is null or empty");
        return nullptr;
    }
    if (!qos_policies) {
        RMW_SET_ERROR_MSG("qos_policies is null");
        return nullptr;
    }
    if (node->implementation_identifier != rmw_get_implementation_identifier()) {
        RMW_SET_ERROR_MSG("implementation identifier mismatch");
        return nullptr;
    }

    auto node_impl = static_cast<rmw_dsoftbus::NodeImpl*>(node->data);
    if (!node_impl) {
        RMW_SET_ERROR_MSG("node impl is null");
        return nullptr;
    }

    // Allocate service implementation
    auto srv_impl = new (std::nothrow) rmw_dsoftbus::ServiceImpl();
    if (!srv_impl) {
        RMW_SET_ERROR_MSG("failed to allocate service impl");
        return nullptr;
    }

    srv_impl->node = node_impl;
    srv_impl->service_name = service_name;
    srv_impl->type_name = type_support->typesupport_identifier;

    // Encode service name for dsoftbus
    srv_impl->encoded_name = rmw_dsoftbus::encode_service_for_session(service_name);

    // Create pipe for wait notification
    if (pipe(srv_impl->pipe_fd) != 0) {
        delete srv_impl;
        RMW_SET_ERROR_MSG("failed to create pipe for service");
        return nullptr;
    }

    // Make read end non-blocking
    int flags = fcntl(srv_impl->pipe_fd[0], F_GETFL, 0);
    fcntl(srv_impl->pipe_fd[0], F_SETFL, flags | O_NONBLOCK);

    // Register with dsoftbus - creates session server for this service
    int server_id = rmw_dsoftbus::create_service_server(
        service_name,
        type_support->typesupport_identifier,
        srv_impl);
    if (server_id < 0) {
        close(srv_impl->pipe_fd[0]);
        close(srv_impl->pipe_fd[1]);
        delete srv_impl;
        RMW_SET_ERROR_MSG("failed to create dsoftbus service server");
        return nullptr;
    }
    srv_impl->session_server_id = server_id;

    // Allocate rmw_service_t
    auto service = static_cast<rmw_service_t*>(malloc(sizeof(rmw_service_t)));
    if (!service) {
        delete srv_impl;
        RMW_SET_ERROR_MSG("failed to allocate rmw_service_t");
        return nullptr;
    }

    service->implementation_identifier = rmw_get_implementation_identifier();
    service->data = srv_impl;
    service->service_name = srv_impl->service_name.c_str();

    return service;
}

rmw_ret_t rmw_destroy_service(rmw_node_t * node, rmw_service_t * service)
{
    if (!node) {
        RMW_SET_ERROR_MSG("node is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (!service) {
        RMW_SET_ERROR_MSG("service is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (service->implementation_identifier != rmw_get_implementation_identifier()) {
        RMW_SET_ERROR_MSG("implementation identifier mismatch");
        return RMW_RET_INCORRECT_RMW_IMPLEMENTATION;
    }

    auto srv_impl = static_cast<rmw_dsoftbus::ServiceImpl*>(service->data);
    if (srv_impl) {
        // Unregister from dsoftbus
        rmw_dsoftbus::destroy_service_server(srv_impl->service_name.c_str());
        delete srv_impl;
    }

    free(service);

    return RMW_RET_OK;
}

rmw_ret_t rmw_take_request(
    const rmw_service_t * service,
    rmw_service_info_t * request_header,
    void * ros_request,
    bool * taken)
{
    if (!service) {
        RMW_SET_ERROR_MSG("service is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (!request_header) {
        RMW_SET_ERROR_MSG("request_header is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (!ros_request) {
        RMW_SET_ERROR_MSG("ros_request is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (!taken) {
        RMW_SET_ERROR_MSG("taken is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (service->implementation_identifier != rmw_get_implementation_identifier()) {
        RMW_SET_ERROR_MSG("implementation identifier mismatch");
        return RMW_RET_INCORRECT_RMW_IMPLEMENTATION;
    }

    auto srv_impl = static_cast<rmw_dsoftbus::ServiceImpl*>(service->data);
    if (!srv_impl) {
        RMW_SET_ERROR_MSG("service impl is null");
        return RMW_RET_ERROR;
    }

    std::lock_guard<std::mutex> lock(srv_impl->queue_mutex);

    if (srv_impl->request_queue.empty()) {
        *taken = false;
        return RMW_RET_OK;
    }

    // Get request from queue
    auto& req = srv_impl->request_queue.front();

    // Fill request header with client info
    request_header->source_timestamp.sec = req.message.timestamp_ns / 1000000000ULL;
    request_header->source_timestamp.nsec = req.message.timestamp_ns % 1000000000ULL;
    request_header->received_timestamp = request_header->source_timestamp;
    request_header->request_id.sequence_number = req.request_id;
    // Store client session ID in writer_guid for later response routing
    memset(request_header->request_id.writer_guid, 0, sizeof(request_header->request_id.writer_guid));
    memcpy(request_header->request_id.writer_guid, &req.client_session_id, sizeof(int));

    // Copy request data to ros_request (as serialized data pointer for now)
    // The actual deserialization happens in the RMW layer above
    // For now we store the raw data pointer - caller must handle serialization
    if (!req.message.data.empty()) {
        memcpy(ros_request, req.message.data.data(), req.message.data.size());
    }

    srv_impl->request_queue.pop();
    *taken = true;

    // Drain one byte from pipe to match the notification
    if (srv_impl->pipe_fd[0] >= 0) {
        char c;
        read(srv_impl->pipe_fd[0], &c, 1);
    }

    return RMW_RET_OK;
}

rmw_ret_t rmw_send_response(
    const rmw_service_t * service,
    rmw_request_id_t * request_header,
    void * ros_response)
{
    if (!service) {
        RMW_SET_ERROR_MSG("service is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (!request_header) {
        RMW_SET_ERROR_MSG("request_header is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (!ros_response) {
        RMW_SET_ERROR_MSG("ros_response is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (service->implementation_identifier != rmw_get_implementation_identifier()) {
        RMW_SET_ERROR_MSG("implementation identifier mismatch");
        return RMW_RET_INCORRECT_RMW_IMPLEMENTATION;
    }

    auto srv_impl = static_cast<rmw_dsoftbus::ServiceImpl*>(service->data);
    if (!srv_impl) {
        RMW_SET_ERROR_MSG("service impl is null");
        return RMW_RET_ERROR;
    }

    // Extract client session ID from request header (stored in writer_guid)
    int client_session_id = 0;
    memcpy(&client_session_id, request_header->writer_guid, sizeof(int));

    // Send response via dsoftbus
    // Note: ros_response here is the serialized data - actual serialization happens above this layer
    // For now we treat it as raw bytes
    int ret = rmw_dsoftbus::send_service_response(
        srv_impl->service_name.c_str(),
        client_session_id,
        request_header->sequence_number,
        ros_response,
        64,  // Placeholder size - actual implementation needs proper size
        nullptr);

    if (ret != 0) {
        RMW_SET_ERROR_MSG("failed to send response via dsoftbus");
        return RMW_RET_ERROR;
    }

    return RMW_RET_OK;
}

rmw_ret_t rmw_service_server_is_available(
    const rmw_node_t * node,
    const rmw_client_t * client,
    bool * is_available)
{
    if (!node) {
        RMW_SET_ERROR_MSG("node is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (!client) {
        RMW_SET_ERROR_MSG("client is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (!is_available) {
        RMW_SET_ERROR_MSG("is_available is null");
        return RMW_RET_INVALID_ARGUMENT;
    }
    if (client->implementation_identifier != rmw_get_implementation_identifier()) {
        RMW_SET_ERROR_MSG("implementation identifier mismatch");
        return RMW_RET_INCORRECT_RMW_IMPLEMENTATION;
    }

    auto cli_impl = static_cast<rmw_dsoftbus::ClientImpl*>(client->data);
    if (!cli_impl) {
        RMW_SET_ERROR_MSG("client impl is null");
        return RMW_RET_ERROR;
    }

    // Check service availability via dsoftbus discovery
    *is_available = rmw_dsoftbus::is_service_available(cli_impl->service_name.c_str());

    return RMW_RET_OK;
}

}  // extern "C"
